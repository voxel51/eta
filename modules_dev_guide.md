# ETA Module Developer's Guide

This document describes best practices for contributing modules to ETA. See
`core_dev_guide.md` for instructions on contributing to the core ETA
infrastructure.

## What Are ETA Modules?

Modules are the workhorses of the ETA system. They perform the actual
computations required to process videos and generate specific features or
analytics. Abstractly, the ETA system is a graph whose nodes are modules. In
order to compute a desired analytic, the ETA system chooses a path through the
graph and configures a pipeline of modules to run that traverses the chosen
path through the graph.

Concretely, ETA modules are simply executables that take JSON files as input
and write output data to disk. The input JSON configures a module for execution
by telling it what parameter settings to use, what data to read as input, and
where to write it's output data. Modules must also provide a metadata JSON file
that tells the ETA system what parameters they expect and the input/output
data formats they use. We chose this generic modular architecture for ETA
because we want to support as many third-party modules as possible!

This repository contains many modules implemented in Python using the core ETA
libraries, and this is how most ETA modules will be contributed. However, in
principle modules can be implemented in any language as long as they provide a
valid metadata JSON file. In fact, some modules may live outside this
repository on your local machine, in the cloud, or behind a pay-wall on a
vendor's cloud.


## Module Metadata JSON Files

Every ETA module must provide a metadata JSON file describing the inputs and
outputs of the module. The metadata file contains all the necessary information
to generate configuration JSON files that are passed to a module during
execution. Indeed, the ETA system automatically generates configuration files
whenever it builds and executes pipelines.

The precise syntax of the metadata files is still under development, but here
is a mockup of the metadata file for a fictitious object detector:

```json
{
    "info": {
        "id": "82af03f3fe7d5f8fa96677",
        "name": "ObjectDetector",
        "type": "eta.types.modules.detector",
        "version": "0.1.0",
        "description": "An object detector"
    },
    "inputs": [
        {
            "name": "raw_video_path",
            "value": "string",
            "type": "eta.types.data.video",
            "description": "The input video"
        }
    ],
    "outputs": [
        {
            "name": "objects_json_path",
            "value": "string",
            "type": "eta.core.objects.Frame",
            "description": "The output path for the objects JSON file"
        },
        {
            "name": "annotated_frames_path",
            "value": "string",
            "type": "eta.types.data.images",
            "default": null,
            "description": "The output path for the annotated frames"
        }
    ],
    "parameters": [
        {
            "name": "labels",
            "value": "array",
            "type": null,
            "description": "The classes of objects to detect"
        },
        {
            "name": "weights",
            "value": "string",
            "type": "eta.types.data.weights",
            "default": "/path/to/weights.npz",
            "description": "The weights for the network"
        }
    ]
}
```

When discussing metadata files, we refer to each JSON object `{}` as a **spec**
(specification) because it specifies the semantics of a certain entity, and we
refer to the keys of a JSON object (e.g., "info") as **fields**.

The metadata file contains the following top-level fields:

- `info`: a spec containing basic information about the module

- `inputs`: a list of specs describing each input data-related field that
    the module expects in it's configuration file

- `outputs`: a list of specs describing each output data-related field that
    the module expects in it's configuration file

- `parameters`: a list of specs describing additional parameters that the
    module expects in it's configuration file

The `info` spec contains the following fields:

- `id`: the ID of the module, which is a unique identifier generated by the ETA
    maintainers when a new module is registered with the ETA system

- `name`: the name of the module

- `type`: the type of the module, i.e., what computation it performs. Must be a
    valid module type exposed by the ETA library

- `version`: the current module version

- `description`: a short free-text description of the module purpose and
    implementation

The remaining specs describe the fields in the module's configuration files.
Each spec has the fields:

- `name`: the name of the field

- `value`: the JSON value type of this field (string, array, null, etc.)

- `type`: the ETA type of the data referenced by this field. Must be a valid
    data type exposed by the ETA library

- `default`: an optional default value for the field. When the default field
    is specified, this field is optional in configuration files. When no
    default value is provided, this field is mandatory

- `description`: a short free-text description of the field


## Module Configuration Files

The module metadata file contains all the information necessary for the ETA
system to automatically generate module configuration JSON files for a module.

The precise syntax of the configuration files is still under development,
but the current format is:

```json
{
    "data": [
        {<inputs1>, <outputs1>},
        {<inputs2>, <outputs2>},
        ...
    ],
    "param1": <val1>,
    "param2": <val2>,
    ...
}
```

The `data` field contains a list of specs, each of which contains the input
and output fields specified by the module's metadata file. This field expects
a list so that multiple datasets can be processed by in a single module
execution, if desired. The remaining fields contain the parameters specified
by the module's metadata file.

For example, a valid configuration file for the fictitious object detector
defined by the above metadata file is:

```json
{
    "data": [
        {
            "raw_video_path": "/path/to/vid1.mov",
            "objects_json_path": "/path/to/obj1/%05d.json",
            "annotated_frames_path": "/path/to/ann1/%05d.png"
        },
        {
            "raw_video_path": "/path/to/vid2.mp4",
            "objects_json_path": "/path/to/obj2/%05d.json"
        }
    ],
    "labels": ["car", "truck", "bus"],
    "weights": "/path/to/better/weights.npz"
}
```

Note that the `annotated_frames_path` is omitted from the second data spec,
which is allowed since the field was optional (i.e., a default value was
provided in the metadata file).


## Building Standalone Modules

Since ETA modules are just executables, they can be implemented in any language
as long as they provide a valid metadata file and write outputs their outputs
in ETA-supported formats.

Even if you don't intend to develop using ETA, you must be familiar with the
ETA supported data types.


## Building Modules Using ETA

ETA provides a core library that can be leveraged to easily define new
analytics modules. This is the most common method for creating new modules.

This section summarizes the key features of the ETA module creation syntax.

#### Parsing module configuration files

The following snippet shows a canonical definition of a module configuration in
ETA:

```python
from eta.core.config import Config

class ExampleConfig(Config):
    '''An example config class.'''

    def __init__(self, d):
        self.data = self.parse_object_array(d, "data", DataConfig)


class DataConfig(Config):
    '''An example data config class.'''

    def __init__(self, d):
        self.input_path = self.parse_string(d, "input_path")
        self.output_path = self.parse_string(d, "output_path")
        self.parameter = self.parse_number(d, "parameter", default=1.0)
```

The snippet defines a configuration class called `ExampleConfig` which contains
a single `data` field that contains an array of `DataConfig` instances.

Note that the `ExampleConfig` and `DataConfig` classes derive from the
`eta.core.config.Config` class, which implements the basic semantics of
configuration classes. In particular, the `Config.parse_*` methods are used
to define the names and data types of the JSON fields.

Fields defined with no `default` keyword are *mandatory*, and fields with a
`default` keyword are *optional*.

The following JSON file is a valid `ExampleConfig` configuration file:

```json
{
    "data": [
        {
            "input_path": "/path/to/input.mp4",
            "output_path": "/path/to/output.mp4"
        }
    ]
}
```

Note that the `parameter` field is omitted, which is allowed since a default
value was specified in the `DataConfig` class.

To load the configuration file into an `ExampleConfig` instance, simply do:

```python
# Load config from JSON
example_config = ExampleConfig.from_json(path)
```

The `from_json` method, which is inherited from the super class
`eta.core.serial.Serializable`, reads the JSON dictionary and passes it to the
`ExampleConfig` constructor.


#### Defining new data types

In ETA, data is usually written to disk in JSON format. The following snippet
demonstrates how to define a custom data type in ETA:

```python
from eta.core.serial import Serializable

class Point(Serializable):
    '''An (x, y) point.'''

    def __init__(self, x, y):
        self.x = x
        self.y = y

    @classmethod
    def from_dict(cls, d):
        '''Constructs a Point from a JSON dictionary.'''
        return cls(d["x"], d["y"])
```

Note that `Point` derives from the `eta.core.serial.Serializable` class, which
implements the semantics of classes that are meant to be read/written to JSON.

To write a `Point` instance to a JSON file, simply do:

```python
from eta.core import utils

# Serialize Point to JSON
point = Point(0, 1)
utils.write_json(point, path)
```

This code produces the JSON file:

```json
{
    "x": 0,
    "y": 1
}
```

To load the `Point` from JSON, simply do:

```python
# Load Point from JSON
point = Point.from_json(path)
```

The `eta.core.serial.Serializable` class provides the `from_json` method, which
internally calls `Point.from_dict` to parse the JSON data.


#### Building objects from configuration files

Often in ETA, one may want to define a class that can be initialized from a
configuration file. Furthermore, one may have multiple classes that all derive
from a common base class (e.g., different types of filters to apply to an
image), and one wants to select and configure a particular type of filter from
in a configuration file. The `eta.core.config.Configurable` class is provided
to facilitate these use cases.

Consider the following definitions:

```python
import math
from eta.core.config import Config, Configurable

class ShapeConfig(Config):
    '''Parses a Shape config.'''

    def __init__(self, d):
        self.type = self.parse_string(d, "type")
        self._shape, config_cls = Configurable.parse(__name__, self.type)
        self.config = self.parse_object(d, "config", config_cls)

    def build(self):
        '''Builds the Shape instance specified by the config.'''
        return self._shape(self.config)


class Shape(Configurable):
    '''Base class for shapes.'''

    def area(self):
        raise NotImplementedError("subclass must implement area()")


class CircleConfig(Config):
    '''Configuration settings for a circle.'''

    def __init__(self, d):
        self.radius = self.parse_number(d, "radius")


class Circle(Shape):
    '''Class representing a circle.'''

    def __init__(self, config):
        self.validate(config)
        self.config = config

    def area(self):
        return math.pi * self.config.radius ** 2.0
```

The above code define a `Shape` base class and a `Circle` class that
derives from it. Note that the `Shape` class derives from `Configurable`, since
we intend to instantiate shapes from configuration files.

Along with these classes, a `ShapeConfig` class is defined that uses the
`Configurable.parse` method to dynamically load the shape's type from the
configuration file and then build it's config instance. The class also provides
a `build` method to instantiate the shape from its config. Finally, the
`CircleConfig` class is provided to specify the semantics of a `Circle`
configuration file.

We can use the above definitions to parse configuration files like this:

```json
{
    "type": "Circle",
    "config": {
        "radius": 1.0
    }
}
```

To load the configuration file and build the shape, simply do:

```python
# Load Circle configured in JSON
shape_config = ShapeConfig.from_json(path)
circle = shape_config.build()

area = circle.area()  # pi
```
