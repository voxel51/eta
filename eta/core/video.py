'''
Core video processing tools.

ETA uses OpenCV for some of its image-related processing.  OpenCV stores its
images in BGR format.  ETA stores its images in RGB format.  This module's
contract is that it expects RGB to be passed to it and RGB to be expected from
it.  This includes video frames.

Copyright 2017-2018, Voxel51, LLC
voxel51.com

Brian Moore, brian@voxel51.com
Jason Corso, jason@voxel51.com
'''
# pragma pylint: disable=redefined-builtin
# pragma pylint: disable=unused-wildcard-import
# pragma pylint: disable=wildcard-import
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals
from builtins import *
import six
# pragma pylint: enable=redefined-builtin
# pragma pylint: enable=unused-wildcard-import
# pragma pylint: enable=wildcard-import

import errno
import json
import logging
import os
from subprocess import Popen, PIPE
import threading

import cv2
import numpy as np

import eta.core.image as etai
from eta.core.serial import Serializable
import eta.core.utils as etau


logger = logging.getLogger(__name__)


SUPPORTED_VIDEO_FORMATS = [
    ".mp4", ".mpg", ".mpeg", ".avi", ".mov", ".wmv", ".flv", ".mkv"
]


def is_supported_video_file(path):
    '''Determines whether the given file has a supported video type.

    This method does not support videos reprsesented as image sequences (i.e.,
    it will return False for them).

    Args:
        path: the path to a video file

    Returns:
        True/False if the file has a supported video type
    '''
    return os.path.splitext(path)[1] in SUPPORTED_VIDEO_FORMATS


def is_same_video_file_format(path1, path2):
    '''Determines whether the video files have the same supported format.

    This method does not support videos reprsesented as image sequences (i.e.,
    it will return False for them).

    Args:
        path1: the path to a video file
        path2: the path to a video file
    '''
    return (
        is_supported_video_file(path1) and
        os.path.splitext(path1)[1] == os.path.splitext(path2)[1]
    )


def is_valid_video_file(path):
    '''Determines if the given video file is valid, i.e., it has a supported
    type and can be read by our system.

    This method does not support videos reprsesented as image sequences (i.e.,
    it will return False for them).

    Args:
        path: the path to a video file

    Returns:
        True/False if the video is valid
    '''
    if not is_supported_video_file(path):
        return False
    try:
        with FFmpegVideoReader(path):
            return True
    except etau.ExecutableRuntimeError:
        return False



def glob_videos(dir_):
    '''Returns an iterator over all supported video files in the directory.'''
    return etau.multiglob(
        *SUPPORTED_VIDEO_FORMATS, root=os.path.join(dir_, "*"))


class VideoStreamInfo(Serializable):
    '''Class encapsulating the stream info for a video.'''

    def __init__(self, stream_info):
        '''Constructs a VideoStreamInfo instance.

        This constructor should not normally be called directly. The proper way
        to instantiate this class is via the `build_for` factory method.

        Args:
            stream_info: a stream info dictionary generated by get_stream_info
        '''
        self.stream_info = stream_info

    @property
    def encoding_str(self):
        '''Return the video encoding string.'''
        return str(self.stream_info["codec_tag_string"])

    @property
    def frame_size(self):
        '''The (width, height) of each frame.'''
        return (
            int(self.stream_info["width"]),
            int(self.stream_info["height"]),
        )

    @property
    def aspect_ratio(self):
        '''The aspect ratio of the video.'''
        width, height = self.frame_size
        return width * 1.0 / height

    @property
    def frame_rate(self):
        '''The frame rate.'''
        try:
            try:
                num, denom = self.stream_info["avg_frame_rate"].split("/")
                return float(num) / float(denom)
            except ZeroDivisionError:
                num, denom = self.stream_info["r_frame_rate"].split("/")
                return float(num) / float(denom)
        except (KeyError, ValueError):
            raise VideoStreamInfoError(
                "Unable to determine frame rate from stream info")

    @property
    def total_frame_count(self):
        '''The total number of frames in the video, or 0 if it could not be
        determined.
        '''
        try:
            # this fails for directories of frames
            return int(self.stream_info["nb_frames"])
        except KeyError:
            # this seems to work for directories of frames
            return int(self.stream_info.get("duration_ts", 0))

    def get_raw_value(self, key):
        '''Gets a value from the raw stream info dictionary.

        Args:
            key: the key to lookup in the stream info dictionary

        Returns:
            the value for the given key

        Raises:
            KeyError: if the key was not found in the stream info dictionary
        '''
        return self.stream_info[key]

    @classmethod
    def build_for(cls, inpath):
        '''Builds a VideoStreamInfo object for the given video using
        `ffprobe -show_streams`.

        Args:
            inpath: the path to the input video

        Returns:
            a VideoStreamInfo instance
        '''
        return cls(get_stream_info(inpath))

    @classmethod
    def from_dict(cls, d):
        '''Constructs a VideoStreamInfo from a JSON dictionary.'''
        return cls(d["stream_info"])


class VideoStreamInfoError(Exception):
    '''Exception raised when an invalid video stream info dictionary is
    encountered.
    '''
    pass


def get_stream_info(inpath):
    '''Get stream info for the video using `ffprobe -show_streams`.

    Args:
        inpath: video path

    Returns:
        stream: a dictionary of stream info

    Raises:
        FFprobeError: if no stream info was found
    '''
    ffprobe = FFprobe(opts=[
        "-show_streams",             # get stream info
        "-print_format", "json",     # return in JSON format
    ])
    out = ffprobe.run(inpath, decode=True)

    try:
        info = json.loads(out)

        for stream in info["streams"]:
            if stream["codec_type"] == "video":
                return stream

        logger.warning(
            "No stream found with codec_type = video. Returning the first "
            "stream")
        return info["streams"][0]  # default to the first stream
    except Exception:
        raise FFprobeError("Unable to get stream info for '%s'" % inpath)


def get_encoding_str(inpath, use_ffmpeg=True):
    '''Get the encoding string of the input video.

    Args:
        inpath: video path
        use_ffmpeg: whether to use ffmpeg (True) or OpenCV (False)
    '''
    r = FFmpegVideoReader(inpath) if use_ffmpeg else OpenCVVideoReader(inpath)
    with r:
        return r.encoding_str


def get_frame_rate(inpath, use_ffmpeg=True):
    '''Get the frame rate of the input video.

    Args:
        inpath: video path
        use_ffmpeg: whether to use ffmpeg (True) or OpenCV (False)
    '''
    r = FFmpegVideoReader(inpath) if use_ffmpeg else OpenCVVideoReader(inpath)
    with r:
        return r.frame_rate


def get_frame_size(inpath, use_ffmpeg=True):
    '''Get the frame (width, height) of the input video.

    Args:
        inpath: video path
        use_ffmpeg: whether to use ffmpeg (True) or OpenCV (False)
    '''
    r = FFmpegVideoReader(inpath) if use_ffmpeg else OpenCVVideoReader(inpath)
    with r:
        return r.frame_size


def get_frame_count(inpath, use_ffmpeg=True):
    '''Get the number of frames in the input video.

    Args:
        inpath: video path
        use_ffmpeg: whether to use ffmpeg (True) or OpenCV (False)
    '''
    r = FFmpegVideoReader(inpath) if use_ffmpeg else OpenCVVideoReader(inpath)
    with r:
        return r.total_frame_count


def get_raw_frame_number(raw_frame_rate, raw_frame_count, fps, sampled_frame):
    '''Get the raw frame number corresponding to the given sampled frame
    number.

    This function assumes that the sampling was performed using the command
    ```
    FFmpegVideoSampler(fps).run(raw_video_path, ...)
    ```

    Args:
        raw_frame_rate: the frame rate of the raw video
        raw_frame_count: the number of frames in the raw video
        fps: the sampling rate that was used
        sampled_frame: the sampled frame number

    Returns:
        raw_frame: the raw frame number from the input video corresponding to
            the given sampled frame number
    '''
    delta = raw_frame_rate / (1.0 * fps)
    raw_frame = np.minimum(
        np.ceil(delta * (sampled_frame - 0.5)), raw_frame_count)
    return int(raw_frame)


def sample_first_frames(inpath, k, size=None):
    '''Samples the first k frames in a video.

    Args:
        inpath: path to the input video
        k: number of frames to extract
        size: an optional [width, height] to resize the sampled frames. By
            default, the native dimensions of the frames are used

    Returns:
        A numpy array of size [k, height, width]
    '''
    imgs = []
    frames = "1-%d" % k
    with FFmpegVideoReader(inpath, frames=frames) as vr:
        for img in vr:
            if size:
                img = etai.resize(img, *size)
            imgs.append(img)
    return np.array(imgs)


def uniformly_sample_frames(inpath, k, size=None):
    '''Uniformly samples k frames from the video, always including the first
    and last frames.

    Args:
        inpath: path to the input video
        k: the number of frames to extract
        size: an optional [width, height] to resize the sampled frames. By
            default, the native dimensions of the frames are used

    Returns:
        A numpy array of size [k, height, width]
    '''
    imgs = []
    num_frames = get_frame_count(inpath)
    frames = [int(round(i)) for i in np.linspace(1, num_frames, k)]
    with FFmpegVideoReader(inpath, frames=frames) as vr:
        for img in vr:
            if size:
                img = etai.resize(img, *size)
            imgs.append(img)
    return np.array(imgs)


def sliding_window_sample_frames(inpath, k, stride, size=None):
    '''Samples clips from the video using a sliding window of the given
    length and stride.

    Args:
        inpath: path to the input video
        k: the size of each window
        stride: the stride for sliding window
        size: an optional [width, height] to resize the sampled frames. By
            default, the native dimensions of the frames are used

    Returns:
        A numpy array of size [XXXX, k, height, width]
    '''
    # Determine clip indices
    num_frames = get_frame_count(inpath)
    delta = np.arange(1, k + 1)
    offsets = np.array(list(range(0, num_frames + 1 - k, stride)))
    clip_inds = offsets[:, np.newaxis] + delta[np.newaxis, :]

    # Read frames
    imgs = {}
    frames = list(np.unique(clip_inds))  # only read the necessary frames
    with FFmpegVideoReader(inpath, frames=frames) as vr:
        for img in vr:
            if size:
                img = etai.resize(img, *size)
            imgs[vr.frame_number] = img

    # Generate clips tensor
    clips = []
    for inds in clip_inds:
        clips.append(np.array([imgs[k] for k in inds]))
    return np.array(clips)


class VideoProcessor(object):
    '''Class for reading a video and writing a new video frame-by-frame.

    The typical usage is:
    ```
    with VideoProcessor(...) as p:
        for img in p:
            new_img = ... # process img
            p.write(new_img)
    ```
    '''

    def __init__(
            self,
            inpath,
            frames="*",
            in_use_ffmpeg=True,
            out_use_ffmpeg=True,
            out_images_path=None,
            out_video_path=None,
            out_clips_path=None,
            out_fps=None,
            out_size=None,
            out_opts=None):
        '''Constructs a new VideoProcessor instance.

        Args:
            inpath: path to the input video. Passed directly to a VideoReader
            frames: a string specifying the range(s) of frames to process.
                Passed directly to a VideoReader
            in_use_ffmpeg: whether to use FFmpegVideoReader to read input
                videos rather than OpenCVVideoReader
            out_use_ffmpeg: whether to use FFmpegVideoWriter to write output
                videos rather than OpenCVVideoWriter
            out_images_path: a path like "/path/to/frames/%05d.png" with one
                placeholder that specifies where to save frames as individual
                images when the write() method is called. When out_images_path
                is None or "", no images are written
            out_video_path: a path like "/path/to/video.mp4" that specifies
                where to save a single output video that contains all of the
                frames passed to the write() method concatenated together,
                regardless of any potential frame range gaps. When
                out_video_path is None or "", no video is written
            out_clips_path: a path like "/path/to/video/%05d-%05d.mp4" with two
                placeholders that specifies where to save output video clips
                for each frame range when the write() method is called. When
                out_clips_path is None or "", no videos are written
            out_fps: a frame rate for the output video, if any. If the input
                source is a video and fps is None, the same frame rate is used
            out_size: the frame size for the output video, if any. If out_size
                is None, the input frame size is assumed
            out_opts: a list of output video options for ffmpeg. Passed
                directly to FFmpegVideoWriter. Only applicable when
                out_use_ffmpeg = True

        Raises:
            VideoProcessorError: if insufficient options are supplied to
                construct a VideoWriter
        '''
        if in_use_ffmpeg:
            self._reader = FFmpegVideoReader(inpath, frames=frames)
        else:
            self._reader = OpenCVVideoReader(inpath, frames=frames)
        self._video_clip_writer = None
        self._video_writer = None
        self._write_images = bool(out_images_path)
        self._write_video = bool(out_video_path)
        self._write_clips = bool(out_clips_path)

        self.inpath = inpath
        self.frames = frames
        self.in_use_ffmpeg = in_use_ffmpeg
        self.out_use_ffmpeg = out_use_ffmpeg
        self.out_images_path = out_images_path
        self.out_video_path = out_video_path
        self.out_clips_path = out_clips_path
        if out_fps is not None and out_fps > 0:
            self.out_fps = out_fps
        elif self._reader.frame_rate > 0:
            self.out_fps = self._reader.frame_rate
        else:
            raise VideoProcessorError(
                "The inferred frame rate '%s' cannot be used. You must " +
                "manually specify a frame rate" % str(self._reader.frame_rate))
        self.out_size = out_size if out_size else self._reader.frame_size
        self.out_opts = out_opts

        if self._write_video:
            self._video_writer = self._new_video_writer(
                self.out_video_path)

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def __iter__(self):
        return self

    def __next__(self):
        return self.process()

    @property
    def input_frame_size(self):
        '''The (width, height) of each input frame.'''
        return self._reader.frame_size

    @property
    def output_frame_size(self):
        '''The (width, height) of each output frame.'''
        return self.out_size

    @property
    def input_frame_rate(self):
        '''The input frame rate.'''
        return self._reader.frame_rate

    @property
    def output_frame_rate(self):
        '''The output frame rate.'''
        return self.out_fps

    @property
    def frame_number(self):
        '''The current frame number, or -1 if no frames have been read.'''
        return self._reader.frame_number

    @property
    def frame_range(self):
        '''The (first, last) frames for the current range, or (-1, -1) if no
        frames have been read.
        '''
        return self._reader.frame_range

    @property
    def is_new_frame_range(self):
        '''Whether the current frame is the first in a new range.'''
        return self._reader.is_new_frame_range

    @property
    def total_frame_count(self):
        '''The total number of frames in the video.'''
        return self._reader.total_frame_count

    def process(self):
        '''Returns the next frame.'''
        img = self._reader.read()
        if self._write_clips and self._reader.is_new_frame_range:
            self._reset_video_clip_writer()
        return img

    def write(self, img):
        '''Writes the given image to the output writer(s).'''
        if self._write_images:
            etai.write(img, self.out_images_path % self._reader.frame_number)
        if self._write_video:
            self._video_writer.write(img)
        if self._write_clips:
            self._video_clip_writer.write(img)

    def close(self):
        '''Closes the video processor.'''
        self._reader.close()
        if self._video_writer is not None:
            self._video_writer.close()
        if self._video_clip_writer is not None:
            self._video_clip_writer.close()

    def _reset_video_clip_writer(self):
        if self._video_clip_writer is not None:
            self._video_clip_writer.close()

        outpath = self.out_clips_path % self._reader.frame_range
        self._video_clip_writer = self._new_video_writer(outpath)

    def _new_video_writer(self, outpath):
        if self.out_use_ffmpeg:
            return FFmpegVideoWriter(
                outpath, self.out_fps, self.out_size, out_opts=self.out_opts)

        return OpenCVVideoWriter(
            outpath, self.out_fps, self.out_size)


class VideoProcessorError(Exception):
    pass


class VideoReader(object):
    '''Base class for reading videos.'''

    def __init__(self, inpath, frames):
        self.inpath = inpath
        if frames is None:
            self.frames = "1-%d" % self.total_frame_count
            self._ranges = FrameRanges.from_str(self.frames)
        elif isinstance(frames, six.string_types):
            # Frames string
            if frames == "*":
                frames = "1-%d" % self.total_frame_count

            self.frames = frames
            self._ranges = FrameRanges.from_str(frames)
        elif isinstance(frames, list):
            # Frames list
            self._ranges = FrameRanges.from_list(frames)
            self.frames = self._ranges.to_str()
        elif isinstance(frames, (FrameRange, FrameRanges)):
            # FrameRange or FrameRanges
            self._ranges = frames
            self.frames = frames.to_str()
        else:
            raise VideoReaderError("Invalid frames %s" % frames)

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def __iter__(self):
        return self

    def __next__(self):
        return self.read()

    @property
    def frame_number(self):
        '''The current frame number, or -1 if no frames have been read.'''
        return self._ranges.frame

    @property
    def frame_range(self):
        '''The (first, last) frames for the current range, or (-1, -1) if no
        frames have been read.
        '''
        return self._ranges.frame_range

    @property
    def is_new_frame_range(self):
        '''Whether the current frame is the first in a new range.'''
        return self._ranges.is_new_frame_range

    @property
    def encoding_str(self):
        raise NotImplementedError("subclass must implement encoding_str")

    @property
    def frame_size(self):
        raise NotImplementedError("subclass must implement frame_size")

    @property
    def frame_rate(self):
        raise NotImplementedError("subclass must implement frame_rate")

    @property
    def total_frame_count(self):
        raise NotImplementedError("subclass must implement total_frame_count")

    def read(self):
        raise NotImplementedError("subclass must implement read()")

    def close(self):
        raise NotImplementedError("subclass must implement close()")


class VideoReaderError(Exception):
    pass


class FFmpegVideoReader(VideoReader):
    '''Class for reading video using ffmpeg.

    The input video can be a standalone video file like "/path/to/video.mp4"
    or a directory of frames like "/path/to/frames/%5d.png". This path is
    passed directly to ffmpeg.

    A frames string like "1-5,10-15" can optionally be passed to only read
    certain frame ranges.

    This class uses 1-based indexing for all frame operations.
    '''

    def __init__(self, inpath, frames="*"):
        '''Constructs a new VideoReader with ffmpeg backend.

        Args:
            inpath: path to the input video, which can be a standalone video
                file like "/path/to/video.mp4" or a directory of frames like
                "/path/to/frames/%5d.png". This path is passed directly to
                ffmpeg
            frames: one of the following optional quantities specifying a
                collection of frames to process:
                    - None (all frames)
                    - "*" (all frames - the default)
                    - a string like "1-3,6,8-10"
                    - a list like [1, 2, 3, 6, 8, 9, 10]
                    - a FrameRange or FrameRanges instance
        '''
        self._stream_info = VideoStreamInfo.build_for(inpath)
        self._ffmpeg = FFmpeg(
            out_opts=[
                "-f", 'image2pipe',         # pipe frames to stdout
                "-vcodec", "rawvideo",      # output will be raw video
                "-pix_fmt", "rgb24",        # pixel format
            ],
        )
        self._ffmpeg.run(inpath, "-")
        self._raw_frame = None

        super(FFmpegVideoReader, self).__init__(inpath, frames)

    @property
    def encoding_str(self):
        '''Return the video encoding string.'''
        return self._stream_info.encoding_str

    @property
    def frame_size(self):
        '''The (width, height) of each frame.'''
        return self._stream_info.frame_size

    @property
    def frame_rate(self):
        '''The frame rate.'''
        return self._stream_info.frame_rate

    @property
    def total_frame_count(self):
        '''The total number of frames in the video, or 0 if it could not be
        determined.
        '''
        return self._stream_info.total_frame_count

    def read(self):
        '''Reads the next frame.

        Returns:
            img: the next frame

        Raises:
            StopIteration: if there are no more frames to process
            VideoReaderError: if unable to load the next frame from file
        '''
        for _ in range(max(0, self.frame_number), next(self._ranges)):
            if not self._grab():
                raise VideoReaderError(
                    "Failed to grab frame %d" % self.frame_number)
        return self._retrieve()

    def close(self):
        '''Closes the video reader.'''
        self._ffmpeg.close()

    def _grab(self):
        try:
            width, height = self.frame_size
            self._raw_frame = self._ffmpeg.read(width * height * 3)
            return True
        except Exception:
            return False

    def _retrieve(self):
        try:
            vec = np.fromstring(self._raw_frame, dtype="uint8")
            width, height = self.frame_size
            return vec.reshape((height, width, 3))
        except ValueError:
            raise VideoReaderError(
                "Unable to parse frame %d" % self.frame_number)


class OpenCVVideoReader(VideoReader):
    '''Class for reading video using OpenCV.

    The input video can be a standalone video file like "/path/to/video.mp4"
    or a directory of frames like "/path/to/frames/%5d.png". This path is
    passed directly to cv2.VideoCapture. So, for example, if you specify a
    directory of frames, the frame numbering must start from 0-3.

    A frames string like "1-5,10-15" can optionally be passed to only read
    certain frame ranges.

    This class uses 1-based indexing for all frame operations.
    '''

    def __init__(self, inpath, frames="*"):
        '''Constructs a new VideoReader with OpenCV backend.

        Args:
            inpath: path to the input video, which can be a standalone video
                file like "/path/to/video.mp4" or a directory of frames like
                "/path/to/frames/%5d.png". This path is passed directly to
                cv2.VideoCapture
            frames: one of the following optional quantities specifying a
                collection of frames to process:
                    - None (all frames)
                    - "*" (all frames - the default)
                    - a string like "1-3,6,8-10"
                    - a list like [1, 2, 3, 6, 8, 9, 10]
                    - a FrameRange or FrameRanges instance

        Raises:
            VideoReaderError: if the input video could not be opened.
        '''
        self._cap = cv2.VideoCapture(inpath)
        if not self._cap.isOpened():
            raise VideoReaderError("Unable to open '%s'" % inpath)

        super(OpenCVVideoReader, self).__init__(inpath, frames)

    @property
    def encoding_str(self):
        '''Return the video encoding string.'''
        try:
            # OpenCV 3
            code = int(self._cap.get(cv2.CAP_PROP_FOURCC))
        except AttributeError:
            # OpenCV 2
            code = int(self._cap.get(cv2.cv.CV_CAP_PROP_FOURCC))
        return FOURCC.int_to_str(code)

    @property
    def frame_size(self):
        '''The (width, height) of each frame.'''
        try:
            # OpenCV 3
            return (
                int(self._cap.get(cv2.CAP_PROP_FRAME_WIDTH)),
                int(self._cap.get(cv2.CAP_PROP_FRAME_HEIGHT)),
            )
        except AttributeError:
            # OpenCV 2
            return (
                int(self._cap.get(cv2.cv.CV_CAP_PROP_FRAME_WIDTH)),
                int(self._cap.get(cv2.cv.CV_CAP_PROP_FRAME_HEIGHT)),
            )

    @property
    def frame_rate(self):
        '''The frame rate.'''
        try:
            # OpenCV 3
            return float(self._cap.get(cv2.CAP_PROP_FPS))
        except AttributeError:
            # OpenCV 2
            return float(self._cap.get(cv2.cv.CV_CAP_PROP_FPS))

    @property
    def total_frame_count(self):
        '''The total number of frames in the video.'''
        try:
            # OpenCV 3
            return int(self._cap.get(cv2.CAP_PROP_FRAME_COUNT))
        except AttributeError:
            # OpenCV 2
            return int(self._cap.get(cv2.cv.CV_CAP_PROP_FRAME_COUNT))

    def read(self):
        '''Reads the next frame.

        Returns:
            img: the next frame

        Raises:
            StopIteration: if there are no more frames to process
            VideoReaderError: if unable to load the next frame from file
        '''
        for idx in range(max(0, self.frame_number), next(self._ranges)):
            if not self._cap.grab():
                raise VideoReaderError(
                    "Failed to grab frame %d" % (idx + 1))
        return etai.bgr_to_rgb(self._cap.retrieve()[1])

    def close(self):
        '''Closes the video reader.'''
        self._cap.release()


class VideoWriter(object):
    '''Base class for writing videos.'''

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def write(self, img):
        raise NotImplementedError("subclass must implement write()")

    def close(self):
        raise NotImplementedError("subclass must implement close()")


class VideoWriterError(Exception):
    pass


class FFmpegVideoWriter(VideoWriter):
    '''Class for writing videos using ffmpeg.'''

    DEFAULT_OUT_OPTS = [
        "-c:v", "libx264", "-pix_fmt", "yuv420p",
        "-preset", "medium", "-crf", "23", "-an",
    ]

    def __init__(self, outpath, fps, size, out_opts=None):
        '''Constructs a VideoWriter with ffmpeg backend.

        Args:
            outpath: the output video path. Existing files are overwritten,
                and the directory is created if necessary
            fps: the frame rate
            size: the (width, height) of each frame
            out_opts: A list of output options for ffmpeg. If not specified,
                the DEFAULT_OUT_OPTS list is used
        '''
        self.outpath = outpath
        self.fps = fps
        self.size = size
        self.out_opts = out_opts or self.DEFAULT_OUT_OPTS

        self._ffmpeg = FFmpeg(
            in_opts=[
                "-f", "rawvideo",           # input will be raw video
                "-vcodec", "rawvideo",      # input will be raw video
                "-s", "%dx%d" % self.size,  # frame size
                "-pix_fmt", "rgb24",        # pixel format
                "-r", str(self.fps),        # frame rate
            ],
            out_opts=self.out_opts,
        )
        self._ffmpeg.run("-", self.outpath)

    def write(self, img):
        '''Appends the image to the output video.

        Args:
            img: an image in ETA format (RGB)
        '''
        self._ffmpeg.stream(img.tostring())

    def close(self):
        '''Closes the video writer.'''
        self._ffmpeg.close()


class OpenCVVideoWriter(VideoWriter):
    '''Class for writing videos using cv2.VideoWriter.

    Uses the default encoding scheme for the extension of the output path.
    '''

    def __init__(self, outpath, fps, size):
        '''Constructs a VideoWriter with OpenCV backend.

        Args:
            outpath: the output video path. Existing files are overwritten,
                and the directory is created if necessary
            fps: the frame rate
            size: the (width, height) of each frame

        Raises:
            VideoWriterError: if the writer failed to open
        '''
        self.outpath = outpath
        self.fps = fps
        self.size = size
        self._writer = cv2.VideoWriter()

        etau.ensure_path(self.outpath)
        self._writer.open(self.outpath, -1, self.fps, self.size, True)
        if not self._writer.isOpened():
            raise VideoWriterError("Unable to open '%s'" % self.outpath)

    def write(self, img):
        '''Appends the image to the output video.

        Args:
            img: an image in ETA format
        '''
        self._writer.write(etai.rgb_to_bgr(img))

    def close(self):
        '''Closes the video writer.'''
        # self._writer.release()  # warns to use a separate thread
        threading.Thread(target=self._writer.release, args=()).start()


class FFprobe(object):
    '''Interface for the ffprobe binary.'''

    DEFAULT_GLOBAL_OPTS = ["-loglevel", "error"]

    def __init__(
            self,
            executable="ffprobe",
            global_opts=None,
            opts=None,
    ):
        '''Constructs an ffprobe command, minus the input path.

        Args:
            executable: the system path to the ffprobe binary
            global_opts: a list of global options for ffprobe. By default,
                self.DEFAULT_GLOBAL_OPTS is used
            opts: a list of options for ffprobe
        '''
        self._executable = executable
        self._global_opts = global_opts or self.DEFAULT_GLOBAL_OPTS
        self._opts = opts or []

        self._args = None
        self._p = None

    @property
    def cmd(self):
        '''The last executed ffprobe command string, or None if run() has not
        yet been called.
        '''
        return " ".join(self._args) if self._args else None

    def run(self, inpath, decode=False):
        '''Run the ffprobe binary with the specified input path.

        Args:
            inpath: the input path

        Returns:
            out: the stdout from the ffprobe binary
            decode: whether to decode the output bytes into utf-8 strings. By
                default, the raw bytes are returned

        Raises:
            ExecutableNotFoundError: if the ffprobe binary cannot be found
            ExecutableRuntimeError: if the ffprobe binary raises an error
                during execution
        '''
        self._args = (
            [self._executable] +
            self._global_opts +
            self._opts +
            ["-i", inpath]
        )

        try:
            self._p = Popen(
                self._args,
                stdout=PIPE,
                stderr=PIPE,
            )
        except EnvironmentError as e:
            if e.errno == errno.ENOENT:
                raise etau.ExecutableNotFoundError(self._executable)
            else:
                raise

        out, err = self._p.communicate()
        if self._p.returncode != 0:
            raise etau.ExecutableRuntimeError(self.cmd, err)

        return out.decode() if decode else out


class FFprobeError(Exception):
    '''Exception raised when FFprobe was unable to analyze a video.'''
    pass


class FFmpeg(object):
    '''Interface for the ffmpeg binary.'''

    DEFAULT_GLOBAL_OPTS = ["-loglevel", "error"]

    def __init__(
            self,
            executable="ffmpeg",
            global_opts=None,
            in_opts=None,
            out_opts=None,
        ):
        '''Constructs an ffmpeg command, minus the input/output paths.

        Args:
            executable: the system path to the ffmpeg binary
            global_opts: a list of global options for ffmpeg. By default,
                self.DEFAULT_GLOBAL_OPTS is used
            in_opts: a list of input options for ffmpeg
            out_opts: a list of output options for ffmpeg
        '''
        self.is_input_streaming = False
        self.is_output_streaming = False

        self._executable = executable
        self._global_opts = global_opts or self.DEFAULT_GLOBAL_OPTS
        self._in_opts = in_opts or []
        self._out_opts = out_opts or []
        self._args = None
        self._p = None

    @property
    def cmd(self):
        '''The last executed ffmpeg command string, or None if run() has not
        yet been called.
        '''
        return " ".join(self._args) if self._args else None

    def run(self, inpath, outpath):
        '''Run the ffmpeg binary with the specified input/outpath paths.

        Args:
            inpath: the input path. If inpath is "-", input streaming mode is
                activated and data can be passed via the stream() method
            outpath: the output path. Existing files are overwritten, and the
                directory is created if needed. If outpath is "-", output
                streaming mode is activated and data can be read via the
                read() method

        Raises:
            ExecutableNotFoundError: if the ffmpeg binary cannot be found
            ExecutableRuntimeError: if the ffmpeg binary raises an error during
                execution
        '''
        self.is_input_streaming = (inpath == "-")
        self.is_output_streaming = (outpath == "-")

        self._args = (
            [self._executable] +
            self._global_opts +
            self._in_opts + ["-i", inpath] +
            self._out_opts + [outpath]
        )

        if not self.is_output_streaming:
            etau.ensure_path(outpath)

        try:
            logger.debug("Excuting '%s'", self.cmd)
            self._p = Popen(self._args, stdin=PIPE, stdout=PIPE, stderr=PIPE)
        except EnvironmentError as e:
            if e.errno == errno.ENOENT:
                raise etau.ExecutableNotFoundError(self._executable)
            else:
                raise

        # Run non-streaming jobs immediately
        if not (self.is_input_streaming or self.is_output_streaming):
            err = self._p.communicate()[1]
            if self._p.returncode != 0:
                raise etau.ExecutableRuntimeError(self.cmd, err)

    def stream(self, string):
        '''Writes the string to ffmpeg's stdin stream.

        Raises:
            FFmpegStreamingError: if input streaming mode is not active
        '''
        if not self.is_input_streaming:
            raise FFmpegStreamingError("Not currently input streaming")
        self._p.stdin.write(string)

    def read(self, num_bytes):
        '''Reads the given number of bytes from ffmpeg's stdout stream.

        Raises:
            FFmpegStreamingError: if output streaming mode is not active
        '''
        if not self.is_output_streaming:
            raise FFmpegStreamingError("Not currently output streaming")
        return self._p.stdout.read(num_bytes)

    def close(self):
        '''Closes a streaming ffmpeg program.

        Raises:
            FFmpegStreamingError: if a streaming mode is not active
        '''
        if not (self.is_input_streaming or self.is_output_streaming):
            raise FFmpegStreamingError("Not currently streaming")
        self._p.stdin.close()
        self._p.stdout.close()
        self._p.wait()
        self._p = None
        self.is_input_streaming = False
        self.is_output_streaming = False


class FFmpegStreamingError(Exception):
    pass


class FFmpegVideoResizer(FFmpeg):
    '''Class for resizing videos using ffmpeg.

    Example usage:
        resizer = FFmpegVideoResizer(size=(512, -1))
        resizer.run("/path/to/video.mp4", "/path/to/resized.mp4")
    '''

    DEFAULT_OUT_OPTS = [
        "-c:v", "libx264", "-pix_fmt", "yuv420p",
        "-preset", "medium", "-crf", "23", "-an",
    ]

    def __init__(
            self, size=None, scale=None, scale_str=None, out_opts=None,
            **kwargs):
        '''Constructs a video resizer with ffmpeg backend.

        Any one of the `size`, `scale`, and `scale_str` arguments can be
        specified to define the resizing operation.

        Args:
            size: the output (width, height) of each frame. At most one
                dimension can be -1, in which case the aspect ratio is
                preserved
            scale: a positive number by which to scale the input video
                (e.g., 0.5 or 2)
            scale_str: a string that directly specifies a valid ffmpeg scale=
                option
            out_opts: a list of output video options for ffmpeg. Passed
                directly to FFmpeg. If omitted, the DEFAULT_OUT_OPTS are used
            **kwargs: additional optional keyword arguments for FFmpeg
        '''
        if out_opts is None:
            out_opts = self.DEFAULT_OUT_OPTS
        scale_opt = self._gen_scale_opt(
            size=size, scale=scale, scale_str=scale_str)
        if scale_opt:
            out_opts += ["-vf", "scale={0}".format(scale_opt)]
        super(FFmpegVideoResizer, self).__init__(out_opts=out_opts, **kwargs)

    @staticmethod
    def _gen_scale_opt(size=None, scale=None, scale_str=None):
        if size:
            return "{0}:{1}".format(*size)
        if scale:
            return "iw*{0}:ih*{0}".format(scale)
        if scale_str:
            return scale_str

        logger.info("No scale argument found; retaining the native resolution")
        return None


class FFmpegVideoSampler(FFmpeg):
    '''Class for sampling videos using ffmpeg.

    Example usage:
        sampler = FFmpegVideoSampler(fps=10)
        sampler.run("/path/to/video.mp4", "/path/to/sampled.mp4")
    '''

    DEFAULT_OUT_OPTS = [
        "-c:v", "libx264", "-pix_fmt", "yuv420p",
        "-preset", "medium", "-crf", "23", "-an",
    ]

    def __init__(self, fps=None, out_opts=None, **kwargs):
        '''Constructs a video sampler with ffmpeg backend.

        Args:
            fps: an optional sampling rate. By default, the native frame rate
                of the video is used
            out_opts: a list of output video options for ffmpeg. Passed
                directly to FFmpeg. If omitted, the DEFAULT_OUT_OPTS are used
            **kwargs: additional optional keyword arguments for FFmpeg
        '''
        if out_opts is None:
            out_opts = self.DEFAULT_OUT_OPTS
        if fps is not None and fps > 0:
            out_opts += ["-vf", "fps={0}".format(fps)]

        super(FFmpegVideoSampler, self).__init__(out_opts=out_opts, **kwargs)


class FOURCC(object):
    '''Class reprsesenting a FOURCC code.'''

    def __init__(self, _i=None, _s=None):
        '''Don't call this directly!'''
        if _i:
            self.int = _i
            self.str = FOURCC.int_to_str(_i)
        elif _s:
            self.int = FOURCC.str_to_int(_s)
            self.str = _s

    @classmethod
    def from_str(cls, s):
        '''Construct a FOURCC instance from a string.'''
        return cls(_s=s)

    @classmethod
    def from_int(cls, i):
        '''Construct a FOURCC instance from an integer.'''
        return cls(_i=i)

    @staticmethod
    def str_to_int(s):
        '''Convert the FOURCC string to an int.'''
        try:
            # OpenCV 3
            return cv2.VideoWriter_fourcc(*s)
        except AttributeError:
            # OpenCV 2
            return cv2.cv.FOURCC(*s)

    @staticmethod
    def int_to_str(i):
        '''Convert the FOURCC int to a string.'''
        return chr((i & 0x000000FF) >> 0) + \
               chr((i & 0x0000FF00) >> 8) + \
               chr((i & 0x00FF0000) >> 16) + \
               chr((i & 0xFF000000) >> 24)


class FrameRanges(object):
    '''A monotonically increasing and disjoint series of frames.'''

    def __init__(self, ranges):
        '''Constructs a frame range series from a list of (first, last) tuples,
        which must be disjoint and monotonically increasing.

        Raises:
            FrameRangesError: if the series is not disjoint and monotonically
                increasing
        '''
        self._idx = 0
        self._ranges = []
        self._started = False

        end = -1
        for first, last in ranges:
            if first <= end:
                raise FrameRangesError(
                    "Expected first:%d > last:%d" % (first, end))

            self._ranges.append(FrameRange(first, last))
            end = last

    def __iter__(self):
        return self

    def __next__(self):
        '''Returns the next frame number.

        Raises:
            StopIteration: if there are no more frames to process
        '''
        self._started = True
        try:
            frame = next(self._ranges[self._idx])
        except StopIteration:
            self._idx += 1
            return next(self)
        except IndexError:
            raise StopIteration

        return frame

    @property
    def frame(self):
        '''The current frame number, or -1 if no frames have been read.'''
        if self._started:
            return self._ranges[self._idx].idx

        return -1

    @property
    def frame_range(self):
        '''The (first, last) values for the current range, or (-1, -1) if no
        frames have been read.
        '''
        if self._started:
            return self._ranges[self._idx].first, self._ranges[self._idx].last

        return (-1, -1)

    @property
    def is_new_frame_range(self):
        '''Whether the current frame is the first in a new range.'''
        if self._started:
            return self._ranges[self._idx].is_first_frame

        return False

    def to_list(self):
        '''Return a list of frames in the frame ranges.'''
        frames = []
        for r in self._ranges:
            frames += r.to_list()

        return frames

    def to_str(self):
        '''Return a string representation of the frame ranges.'''
        return ",".join([r.to_str() for r in self._ranges])

    @classmethod
    def from_str(cls, frames_str):
        '''Constructs a FrameRanges object from a frames string.

        Args:
            frames_str: a string like "1-3,6,8-10"

        Raises:
            FrameRangesError: if the frames string is invalid
        '''
        ranges = []
        for r in frames_str.split(','):
            if r:
                fr = FrameRange.from_str(r)
                ranges.append((fr.first, fr.last))

        return cls(ranges)

    @classmethod
    def from_list(cls, frames_list):
        '''Constructs a FrameRanges object from a frames list.

        Args:
            frames_list: a list like [1, 2, 3, 6, 8, 9, 10]

        Raises:
            FrameRangesError: if the frames list is invalid
        '''
        return cls(_list_to_ranges(frames_list))


class FrameRangesError(Exception):
    '''Exception raised when an invalid FrameRanges is encountered.'''
    pass


class FrameRange(object):
    '''An iterator over a range of frames.'''

    def __init__(self, first, last):
        '''Constructs a frame range with the given first and last values,
        inclusive.

        Raises:
            FrameRangeError: if last < first
        '''
        if last < first:
            raise FrameRangeError(
                "Expected first:%d <= last:%d" % (first, last))

        self.first = first
        self.last = last
        self.idx = -1

    def __iter__(self):
        return self

    @property
    def is_first_frame(self):
        '''Whether the current frame is first in the range.'''
        return self.idx == self.first

    def __next__(self):
        '''Returns the next frame number.

        Raises:
            StopIteration: if there are no more frames in the range
        '''
        if self.idx < 0:
            self.idx = self.first
        elif self.idx < self.last:
            self.idx += 1
        else:
            raise StopIteration

        return self.idx

    def to_list(self):
        '''Return a list of frames in the range.'''
        return list(range(self.first, self.last + 1))

    def to_str(self):
        '''Return a string representation of the range.'''
        if self.first == self.last:
            return "%d" % self.first

        return "%d-%d" % (self.first, self.last)

    @classmethod
    def from_str(cls, frames_str):
        '''Constructs a FrameRange object from a string.

        Args:
            frames_str: a string like "1-5"

        Raises:
            FrameRangeError: if the frame range string is invalid
        '''
        try:
            v = list(map(int, frames_str.split('-')))
            return cls(v[0], v[-1])
        except ValueError:
            raise FrameRangeError(
                "Invalid frame range string '%s'" % frames_str)

    @classmethod
    def from_list(cls, frames_list):
        '''Constructs a FrameRange object from a frames list.

        Args:
            frames_list: a consecutive list like [1, 2, 3, 4, 5]

        Raises:
            FrameRangeError: if the frame range list is invalid
        '''
        ranges = list(_list_to_ranges(frames_list))
        if len(ranges) != 1:
            raise FrameRangeError("Invalid frame range list %s" % frames_list)

        return cls(*ranges[0])


class FrameRangeError(Exception):
    '''Exception raised when an invalid FrameRange is encountered.'''
    pass


def _list_to_ranges(vals):
    if not vals:
        raise StopIteration

    vals = sorted(vals)
    first = last = vals[0]
    for val in vals[1:]:
        if val == last + 1:
            last += 1
        else:
            yield (first, last)
            first = last = val

    yield (first, last)
